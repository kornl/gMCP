\documentclass[a4paper, 10pt]{report}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{caption}

\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{decorations,arrows,shapes}
\usepackage[margin=0.9in]{geometry}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xspace}
\usepackage{tabularx}
\usepackage{makeidx}\makeindex
%\usepackage[numbers]{natbib}
\usepackage{natbib}
\bibliographystyle{plainnat}
\usepackage{algorithmic} 
\usepackage{algorithm}
%\usepackage[left=3cm,right=3cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\setlength{\parindent}{0mm}
\setlength{\parskip}{1mm}
\newcommand{\commentout}[1]{}
\renewcommand{\theequation}{\thesection.\arabic{\equation}}
\numberwithin{equation}{section}

\theoremstyle{definition}
\newtheorem{Def}{Definition}[section]
\newtheorem{Rem}[Def]{Remark}
\newtheorem{RemDef}[Def]{Remark und Definition}
\newtheorem{DefRem}[Def]{Definition und Remark}
\newtheorem{Example}[Def]{Example}
\theoremstyle{plain}
\newtheorem{Theorem}[Def]{Theorem}
\newtheorem{DefTheorem}[Def]{Definition and Theorem}
\newtheorem{Corollary}[Def]{Corollary}
\newtheorem{Lemma}[Def]{Lemma}

\newcommand{\C}{\ensuremath{\mathbb{C}}\xspace}
\newcommand{\R}{\ensuremath{\mathbb{R}}\xspace}
\newcommand{\Q}{\ensuremath{\mathbb{Q}}\xspace}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}\xspace}
\newcommand{\NN}{\ensuremath{\mathbb{N}_0}\xspace}
\newcommand{\N}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\sF}{\ensuremath{\mathcal{F}}\xspace}
\newcommand{\sN}{\ensuremath{\mathcal{N}}\xspace}
\newcommand{\Pot}{\ensuremath{\mathfrak{Pot}}\xspace}
\newcommand{\kronecker}{\raisebox{1pt}{\ensuremath{\:\otimes\:}}}

\DeclareMathOperator{\range}{range}

\newcommand{\skp}[1]{\left\langle#1\right\rangle}

\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\newcommand{\id}{\text{id}}

\newenvironment{Proof}{\par\noindent\upshape\textit{Proof. }\nopagebreak}{\qed\par}

%\usepackage{setspace}
%\onehalfspacing

\begin{document}

% \VignetteEngine{knitr::knitr}
% \VignetteIndexEntry{A Graphical Approach to Weighted Multiple Test Procedures}
% \VignetteDepends{coin}

\title{gMCP - an R package for a graphical approach to weighted multiple test procedures} 

%\author{Kornelius Rohmeyer}

%\maketitle\thispagestyle{empty}\vspace*{1cm}

<<OptionsAndLibraries, include=FALSE, message=FALSE>>=
# knitr has to be loaded for 'set_parent' and CRAN checks and also for opt_chunk during build process.
library(knitr)
if (exists("opts_chunk")) {
  opts_chunk$set(concordance=TRUE)
  opts_chunk$set(tidy.opts=list(keep.blank.line=FALSE, width.cutoff=95))
  opts_chunk$set(size="footnotesize")
  opts_chunk$set(cache=FALSE)
  opts_chunk$set(autodep=TRUE)
}
library(gMCP, quietly=TRUE)
options(width=140)
options(digits=4)
gMCPReport <- function(...) {invisible(NULL)}
graphGUI <- function(...) {invisible(NULL)}
#options(prompt="> ", continue="+ ")

@

\section*{Algorithm:}

Need function $p[[i]]:\;\R\rightarrow [0,1]$ (continuous and growing). We first consider the simple case of independent $Z$-tests.

<<>>=
m <- 3
theta <- rep(2, m)
s <- rep(1, m)

p <- list()
for (i in 1:m) {
  p[[i]] <- function(mu) {(pnorm((theta[i]-mu)/s[i])) }
}
@

<<fig.width=5.5, fig.height=5.5, out.width=".5\\linewidth", out.height=".5\\linewidth", fig.align="center", echo=FALSE>>=
plot(p[[1]], xlim=c(-1,5))
@

Then we need the function $V[[j]]:\;\R^m\rightarrow [0,1]$ (continuous and component-wise non-decreasing), which we get in the following way:

We start with a graph $G$.

<<>>=

library(gMCP)
G <- BonferroniHolm(3)

@

\begin{center}
<<echo=TRUE, results='asis'>>=
cat(graph2latex(G, scale=0.8))
@
\end{center}

\newpage

For a given $\mu\in\R^m$ we create a graph $G^{(\mu)}_0$ in the following way:

\begin{enumerate}
  \item For all $j$ with $\mu_j > 0$
    \begin{itemize}
      \item
      \item
      \item
    \end{itemize}
  \item For all $j$ with $\mu_j <= 0$ we don't have to do anything, but we remove all edges to these nodes and from these nodes to make the graph simpler.
\end{enumerate}

<<>>=

createGraph <- function(G, mu) {
  for (i in 1:m) {
    G <- gMCP:::addNode(G, paste("H_",i,"^{\\mu}", sep=""), x=getXCoordinates(G)[i], y=getYCoordinates(G)[i]+120)
    M <- G@m
    if (mu[i]>0) {
      for (j in 1:m) {
        if (M[i, j]!=0) {
          #M[i, j] <- paste(gMCP:::getLaTeXFraction(as.numeric(M[i,j])), "(1-q^{\\mu[i]})", sep="\cdot")
          M[i, j] <- paste(M[i,j], "*(1-q^{\\mu[",i,"]})", sep="")
        }
      }
      M[i, dim(M)[1]] <- paste("q^{\\mu[",i,"]}", sep="")
    } else { # We don't have to do the following, but the graph looks cleaner this way:
      M[i,] <- rep(0, dim(M)[1])
      M[,i] <- rep(0, dim(M)[1])
    }
    G@m <- M
  }
  return(G)
}

Gmu <- createGraph(G, mu=c(-1, 1, 2))
Gmu

@

\begin{center}
<<echo=TRUE, results='asis'>>=
cat(graph2latex(Gmu, scale=0.8))
@
\end{center}

<<>>=

getV <- function(G, mu, q) {
  G2 <- replaceVariables(G, variables = list(q=q, mu="mu"), partial=TRUE)
  G2 <- gMCP:::parse2numeric(G2)
  for (i in 1:m) {
    if (mu[i]>0) {
      node <- getNodes(G2)[i]
      G2 <- rejectNode(G2, node)
    }
  }
  m <- length(getNodes(G2))/2
  return(getWeights(G2)[(m+1):(2*m)]/q^mu)
}

getV(G=Gmu, mu=c(-1, 0.1, 2), q=0.5)

@


\subsection*{Initial value}
\[\]

\subsection*{Iterating}

<<>>=

getCI <- function(G, q, p, mu, alpha=0.05) {
  m <- length(getNodes(G))
  for (i in 1:10) {
    Gmu <- createGraph(G, mu=mu)
    V <- getV(G=Gmu, mu=mu, q=q)
    if (i==1) {
      for (j in 1:m) {
        if (p[[j]](mu[j])>q^mu[j]*V[j]*alpha) stop(paste("Wrong initial mu value:\n",
                                                         "p(mu[",j,"])>q^mu[",j,"]*V[",j,"]: ",
                                                         p[[j]](mu[j]),">",q^mu[j],"*",V[j],"*",alpha,"=",q^mu[j]*V[j]*alpha, sep=""))
      }
    }
  }
  return(NULL)
}

getCI(G=G, q=0.5, p=p, alpha=0.05, mu=c(-1, -0.1, -2))

@

\end{document}
